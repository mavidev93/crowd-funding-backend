{
  "language": "Solidity",
  "sources": {
    "contracts/CrowdFund.sol": {
      "content": "pragma solidity 0.8.8;\n\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\n//Errors\nerror CrowdFund__NotOwner();\nerror CrowdFund__OnlyCampaignOwner();\nerror CrowdFund__GoalAmountMustBeMoreThanMinimum();\nerror CrowdFund__PeriodDaysShouldBeBetween1to365();\nerror CrowdFund__NotEnoughContributionAmount();\nerror CrowdFund__CampaignDoesNotExist();\nerror CrowdFund__CampaignIsClosed();\nerror CrowdFund__CantWithdrawGoalNotReached();\nerror CrowdFund__NoContributions();\nerror CrowdFund__ReclaimConditionsDoesNotMet();\nerror CrowdFund__AlreadyWithdraw();\n\ncontract CrowdFund {\n    address payable public owner; //owner of contract\n    uint256 public minimum_goalAmount;\n    uint256 public minimum_fundAmount;\n    using Counters for Counters.Counter;\n    Counters.Counter private _campaignIds;\n    // This is a type for a single Campaign.\n    struct Campaign {\n        address payable campaignOwner;\n        uint256 id;\n        string campaignUrl;\n        string campaignHash;\n        uint256 goalAmount; //in wei\n        uint256 totalAmountFunded; //in wei\n        uint256 deadline;\n        bool goalAchieved;\n        bool isCampaignOpen;\n        bool isExists; //campaign exists or not. Campaign once created always exists even if closed\n        bool isOwnerWithdraw;\n        //stores amount donated by each unique contributor\n    }\n\n    mapping(uint256 => string) public idToHash;\n    mapping(string => Campaign) public hashToCampaign;\n    mapping(string => mapping(address => uint256)) hashToContributions;\n    modifier onlyOwner() {\n        if (msg.sender != owner) revert CrowdFund__NotOwner();\n        _;\n    }\n\n    modifier onlyCampaignOwner(string memory hash) {\n        if (msg.sender != hashToCampaign[hash].campaignOwner)\n            revert CrowdFund__OnlyCampaignOwner();\n        _;\n    }\n\n    modifier campaignShouldExist(string memory hash) {\n        if (!hashToCampaign[hash].isExists)\n            revert CrowdFund__CampaignDoesNotExist();\n        _;\n    }\n\n    //Events\n    event Create(address indexed campaignOwner, uint256 indexed id);\n    event Fund(\n        address indexed from,\n        uint256 indexed amount,\n        uint256 indexed id\n    );\n    event Test(address indexed from, uint256 indexed testId);\n\n    constructor(uint256 _minimum_goalAmount, uint256 _minimum_fundAmount) {\n        owner = payable(msg.sender);\n        minimum_goalAmount = _minimum_goalAmount;\n        minimum_fundAmount = _minimum_fundAmount;\n    }\n\n    //Creation of a campaign\n    function createCampaign(\n        string memory hash,\n        uint256 _goalAmount,\n        uint256 _fundingPeriodInDays\n    ) public {\n        if (_goalAmount < minimum_goalAmount)\n            revert CrowdFund__GoalAmountMustBeMoreThanMinimum();\n        if (_fundingPeriodInDays < 1 || _fundingPeriodInDays > 365)\n            revert CrowdFund__PeriodDaysShouldBeBetween1to365();\n\n        //id of first campaign is 1 and not 0\n        _campaignIds.increment();\n        uint256 campaignId = _campaignIds.current();\n        idToHash[campaignId] = hash;\n        Campaign storage aCampaign = hashToCampaign[hash];\n        aCampaign.campaignOwner = payable(msg.sender);\n        aCampaign.id = campaignId;\n        aCampaign.campaignHash = hash;\n\n        aCampaign.goalAmount = _goalAmount;\n        aCampaign.totalAmountFunded = 0;\n        aCampaign.deadline = block.timestamp + _fundingPeriodInDays * 1 days;\n        aCampaign.goalAchieved = false;\n        aCampaign.isCampaignOpen = true;\n        aCampaign.isExists = true;\n        aCampaign.isOwnerWithdraw = false;\n        emit Create(msg.sender, campaignId);\n    }\n\n    //Funding of a campaign\n    function fundCampaign(string memory hash)\n        public\n        payable\n        campaignShouldExist(hash)\n    {\n        if (msg.value < minimum_fundAmount)\n            revert CrowdFund__NotEnoughContributionAmount();\n        checkCampaignDeadline(hash);\n\n        if (!hashToCampaign[hash].isCampaignOpen)\n            revert CrowdFund__CampaignIsClosed();\n        checkCampaignDeadline(hash);\n        hashToContributions[hash][msg.sender] =\n            (hashToContributions[hash][msg.sender]) +\n            msg.value;\n        hashToCampaign[hash].totalAmountFunded =\n            hashToCampaign[hash].totalAmountFunded +\n            msg.value;\n        emit Fund(msg.sender, msg.value, hashToCampaign[hash].id);\n        //Check If funding Goal Achieved\n        if (\n            hashToCampaign[hash].totalAmountFunded >=\n            hashToCampaign[hash].goalAmount\n        ) {\n            hashToCampaign[hash].goalAchieved = true;\n        }\n    }\n\n    // Withdraw of funds by Campaign Owner\n    function withdrawFunds(string memory hash)\n        public\n        onlyCampaignOwner(hash)\n        campaignShouldExist(hash)\n    {\n        if (!hashToCampaign[hash].goalAchieved)\n            revert CrowdFund__CantWithdrawGoalNotReached();\n        if (hashToCampaign[hash].isOwnerWithdraw)\n            revert CrowdFund__AlreadyWithdraw();\n        payable(msg.sender).transfer(hashToCampaign[hash].totalAmountFunded);\n        hashToCampaign[hash].isOwnerWithdraw = true;\n        hashToCampaign[hash].isCampaignOpen = false; //Close the campaign\n    }\n\n    //Reclaim of funds by a contributor\n    function claimRefund(string memory hash) public campaignShouldExist(hash) {\n        if (hashToContributions[hash][msg.sender] <= 0)\n            revert CrowdFund__NoContributions();\n\n        checkCampaignDeadline(hash);\n\n        if (\n            (hashToCampaign[hash].isCampaignOpen) ||\n            (hashToCampaign[hash].goalAchieved)\n        ) revert CrowdFund__ReclaimConditionsDoesNotMet();\n\n        payable(msg.sender).transfer(hashToContributions[hash][msg.sender]);\n        hashToContributions[hash][msg.sender] = 0;\n    }\n\n    //Campaign owner can close a campaign anytime\n    function closeCampaign(string memory hash) public onlyCampaignOwner(hash) {\n        if (!hashToCampaign[hash].isCampaignOpen)\n            revert CrowdFund__CampaignIsClosed();\n        hashToCampaign[hash].isCampaignOpen = false;\n    }\n\n    // Contributor can view his/her contribution details for a campaign\n    function getContributions(string memory hash)\n        public\n        view\n        campaignShouldExist(hash)\n        returns (uint256 contribution)\n    {\n        return hashToContributions[hash][msg.sender];\n    }\n\n    //To check whether a campaign deadline has passed\n    function checkCampaignDeadline(string memory hash)\n        internal\n        campaignShouldExist(hash)\n    {\n        if (block.timestamp > hashToCampaign[hash].deadline) {\n            hashToCampaign[hash].isCampaignOpen = false; //Close the campaign\n        }\n    }\n\n    function getAllCampaigns() public view returns (Campaign[] memory) {\n        uint256 campaignCount = _campaignIds.current();\n        Campaign[] memory campaigns = new Campaign[](campaignCount);\n        for (uint256 i = 0; i < campaignCount; i++) {\n            Campaign storage currentCampaign = hashToCampaign[idToHash[i]];\n            campaigns[i] = currentCampaign;\n        }\n        return campaigns;\n    }\n\n    function getCampaignCount() public view returns (uint256) {\n        return _campaignIds.current();\n    }\n\n    function getHashById(uint256 _id) public view returns (string memory) {\n        return idToHash[_id];\n    }\n\n    function getCampaignByHash(string memory hash)\n        public\n        view\n        returns (Campaign memory)\n    {\n        return hashToCampaign[hash];\n    }\n} // close the contract\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}